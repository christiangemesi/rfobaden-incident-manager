package ch.rfobaden.incidentmanager.backend.test.generators.base;

import ch.rfobaden.incidentmanager.backend.TestConfig;
import com.github.javafaker.Faker;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.stereotype.Component;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Collectors;

/**
 * {@code Generator} is an abstract base class for defining generators.
 * A generator is able to produce random sample data for testing purposes.
 *
 * @param <T> The type of the generated values.
 */
@Component
@Import(TestConfig.class)
public abstract class Generator<T> {
    /**
     * Faker instance used to generate fake values.
     */
    @Autowired
    protected Faker faker;

    /**
     * Generate a value.
     *
     * @return The generated value.
     */
    public abstract T generate();

    /**
     * Generate a list of values.
     *
     * @param amount The amount of values to generate.
     * @return The list of generated values.
     */
    public final List<T> generate(int amount) {
        return generate(amount, this::generate);
    }

    /**
     * Generates a list of values, using a specific {@link Supplier} to generate the values.
     *
     * @param amount The amount of values to generate.
     * @param generate The supplier generating the values.
     * @return The list of generated values.
     *
     * @param <T> The type of the generated values.
     */
    protected static <T> List<T> generate(int amount, Supplier<T> generate) {
        var records = new ArrayList<T>(amount);
        for (int i = 0; i < amount; i++) {
            records.add(generate.get());
        }
        return records;
    }

    /**
     * Generate a boolean that is {@code true} half of the time.
     *
     * @return the generated boolean.
     */
    public boolean randomBoolean() {
        return faker.bool().bool();
    }

    /**
     * Do something half of the time.
     * This method is meant to be used for generating optional test data.
     *
     * @param action The action which is executed half of the time.
     * @param <R> The type of the value generated by the action.
     * @return The value generated by {@code action}, or {@code null},
     *         if the action was not executed.
     */
    public <R> R doMaybe(Supplier<R> action) {
        if (randomBoolean()) {
            return action.get();
        }
        return null;
    }

    /**
     * Generates a random datetime.
     * It is guaranteed to be either now or in the past.
     *
     * @return The generated datetime.
     */
    public LocalDateTime randomDateTime() {
        return LocalDateTime.now()
            .withNano(0)
            .minusDays(faker.random().nextInt(0, 365 * 1000));
    }

    /**
     * Shallow copy of a value, using reflection.
     * Not very pretty, not entirely safe, definitely only usable in testing.
     *
     * <p>
     * This could be made abstract if we ever want to move away from the unsafe,
     * reflection-based type of copying.
     * </p>
     *
     * @param value the value to copy
     *
     * @return a shallow copy of {@code value}
     */
    public T copy(T value) {
        try {
            var clazz = value.getClass();
            Constructor<T> defaultConstructor = null;
            @SuppressWarnings("unchecked") var constructors =
                (Constructor<T>[]) clazz.getConstructors();
            for (var constructor : constructors) {
                if (constructor.getParameterCount() == 0) {
                    defaultConstructor = constructor;
                    break;
                }
            }
            if (defaultConstructor == null) {
                throw new IllegalStateException("can't copy without a default constructor");
            }

            var newValue = defaultConstructor.newInstance();
            var properties = getProperties(value);

            var currentClass = clazz;
            do {
                for (var field : currentClass.getDeclaredFields()) {
                    @SuppressWarnings("unchecked")
                    var property = (Property<T, Object>) properties.get(field.getName());
                    if (property == null) {
                        continue;
                    }
                    property.set(newValue, property.get(value));
                }
                currentClass = currentClass.getSuperclass();
            } while (currentClass != null);
            return newValue;
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
            throw new IllegalStateException("failed to copy", e);
        }
    }

    /**
     * Extracts the readable and writable properties of an object.
     *
     * @param value The object.
     * @return A mapping from property name to property value.
     */
    public Map<String, Property<T, ?>> getProperties(T value) {
        var clazz = value.getClass();
        var methods = Arrays.stream(clazz.getMethods())
            .filter((method) -> (
                method.getName().startsWith("get") || method.getName().startsWith("set")
            ))
            .collect(Collectors.toMap(
                Method::getName,
                (method) -> method
            ));
        var properties = new HashMap<String, Property<T, ?>>();
        methods.forEach((methodName, getter) -> {
            if (!methodName.startsWith("get")) {
                return;
            }
            var setter = methods.get("set" + methodName.substring(3));
            if (setter == null) {
                return;
            }
            var name = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);

            @SuppressWarnings("unchecked")
            var type = (Class<Object>) getter.getReturnType();
            properties.put(name, new Property<>() {
                @Override
                public Class<Object> getType() {
                    return type;
                }

                @Override
                public Object get(T target) {
                    try {
                        return getter.invoke(target);
                    } catch (IllegalAccessException | InvocationTargetException e) {
                        throw new IllegalStateException("failed to access property getter", e);
                    }
                }

                @Override
                public void set(T target, Object value) {
                    try {
                        setter.invoke(target, value);
                    } catch (IllegalAccessException | InvocationTargetException e) {
                        throw new IllegalStateException("failed to access property setter", e);
                    }
                }

                @Override
                public String toString() {
                    return clazz.getSimpleName() + "." + name;
                }
            });
        });
        return properties;
    }

    /**
     * {@code Property} represents a readable and writable value on an object.
     *
     * @param <T> The type of the object.
     * @param <TValue> The type of the property.
     */
    public interface Property<T, TValue> {
        Class<TValue> getType();

        TValue get(T target);

        void set(T target, TValue value);
    }
}
