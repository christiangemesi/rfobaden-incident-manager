package ch.rfobaden.incidentmanager.backend.test.generators.base;

import ch.rfobaden.incidentmanager.backend.TestConfig;
import com.github.javafaker.Faker;
import org.hibernate.tool.schema.internal.exec.ScriptTargetOutputToFile;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.stereotype.Component;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Collectors;

@Component
@Import(TestConfig.class)
public abstract class Generator<T> {
    @Autowired
    protected Faker faker;

    public abstract T generate();

    public final List<T> generate(int amount) {
        return generate(amount, this::generate);
    }

    protected static <T> List<T> generate(int amount, Supplier<T> generate) {
        var records = new ArrayList<T>(amount);
        for (int i = 0; i < amount; i++) {
            records.add(generate.get());
        }
        return records;
    }

    /**
     * Do something half of the time.
     * This method is meant to be used for generating optional test data.
     *
     * @param action The action which is executed half of the time.
     * @param <R> The type of the value generated by the action.
     * @return The value generated by {@code action}, or {@code null},
     *         if the action was not executed.
     */
    protected <R> R doMaybe(Supplier<R> action) {
        if (faker.bool().bool()) {
            return action.get();
        }
        return null;
    }

    protected LocalDateTime randomDateTime() {
        return LocalDateTime.now().minusDays(faker.random().nextInt(0, 365 * 1000));
    }

    /**
     * Shallow copy of a value, using reflection.
     * Not very pretty, not entirely safe, definitely only usable in testing.
     *
     * <p>
     * This could be made abstract if we ever want to move away from the unsafe,
     * reflection-based type of copying.
     * </p>
     *
     * @param value the value to copy
     *
     * @return a shallow copy of {@code value}
     */
    public T copy(T value) {
        try {
            var clazz = value.getClass();
            Constructor<T> defaultConstructor = null;
            @SuppressWarnings("unchecked") var constructors =
                (Constructor<T>[]) clazz.getConstructors();
            for (var constructor : constructors) {
                if (constructor.getParameterCount() == 0) {
                    defaultConstructor = constructor;
                    break;
                }
            }
            if (defaultConstructor == null) {
                throw new IllegalStateException("can't copy without a default constructor");
            }

            var newValue = defaultConstructor.newInstance();
            var methods = Arrays.stream(clazz.getMethods())
                .filter((method) -> (
                    method.getName().startsWith("get") || method.getName().startsWith("set")
                ))
                .collect(Collectors.toMap(
                    Method::getName,
                    (method) -> method
                ));

            var currentClass = clazz;
            do {
                for (var field : currentClass.getDeclaredFields()) {
                    var fieldName = field.getName();
                    var suffix = fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
                    var getter = methods.get("get" + suffix);
                    var setter = methods.get("set" + suffix);
                    if (getter == null || setter == null) {
                        continue;
                    }
                    var propertyValue = getter.invoke(value);
                    setter.invoke(newValue, propertyValue);
                }
                currentClass = currentClass.getSuperclass();
            } while (currentClass != null);
            return newValue;
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
            throw new IllegalStateException("failed to copy", e);
        }
    }
}
